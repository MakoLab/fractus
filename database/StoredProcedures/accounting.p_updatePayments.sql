/*
name=[accounting].[p_updatePayments]
version=1.0.1
lastUpdate=2017-01-24 10:37:21
M0muDuqrz9T4h8WsI+JTpg==
*/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[accounting].[p_updatePayments]') AND type in (N'P', N'PC'))
DROP PROCEDURE [accounting].[p_updatePayments]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[accounting].[p_updatePayments]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [accounting].[p_updatePayments]
@xmlVar XML 
AS
BEGIN



	INSERT INTO dbo.trace VALUES(getdate(),@xmlVar)

	DECLARE @requestId varchar(50)
	DECLARE @action varchar(50)

	DECLARE @rowcount int
	DECLARE @rowcountEettlements int
	DECLARE @rowcountDelete int
	DECLARE	@idoc int
	DECLARE	@i int
	DECLARE @k int
	DECLARE @j int
	DECLARE @ok int
	DECLARE @del int
	DECLARE @amountWork numeric(18,2)

	DECLARE	@commandXml XML
	DECLARE	@localTransactionId uniqueidentifier
	DECLARE	@deferredTransactionId uniqueidentifier

	DECLARE	@conf XML
	DECLARE @symbol NVARCHAR(500)
	DECLARE	@systemCurrencyId uniqueidentifier
	DECLARE	@databaseId uniqueidentifier

	DECLARE	@paymentId uniqueidentifier
	DECLARE	@operation varchar(50)
	DECLARE	@direction int
	DECLARE	@paymentAmount numeric(18,2)
	DECLARE	@amountSettlements numeric(18,2)
	DECLARE	@settlementId uniqueidentifier
	DECLARE @outcomePaymentId uniqueidentifier
	DECLARE @incomePaymentId uniqueidentifier
	DECLARE @dateSettlements datetime
	DECLARE @documentDate datetime
	DECLARE	@ex_paymentId varchar(50)
	DECLARE	@ex_settlements XML
	DECLARE @objectType int

	DECLARE	@amountBO numeric(18,2)
	DECLARE @paymentIdBO uniqueidentifier

	DECLARE	@version uniqueidentifier

	DECLARE @listsContractors XML
	DECLARE @listsPaymentMethod	XML
					
	DECLARE @payments_tmp 
			TABLE 
			(
				id int identity(1,1), 
				paymentId varchar(50),
				paymentMethodId varchar(50), 
				fullNumberDocument nvarchar(500), 
				contractorId varchar(50), 
				documentDate datetime, 
				dueDate datetime, 
				direction char(2),
				amount numeric(18,2), 
				currency varchar(4), 
				exchangeDate datetime, 
				exchangeScale numeric(18,6),
				exchangeRate numeric(18,6), 
				settlements xml, 
				operation varchar(50)
			)
				
	DECLARE @settlements_tmp 
			TABLE 
			(
				[id] uniqueidentifier,
				date datetime,
				[incomePaymentId] uniqueidentifier,	
				[outcomePaymentId] uniqueidentifier,
				[amount] numeric(18, 2),
				[version] uniqueidentifier,
				[isAutoGenerated] bit,
				[outcomePaymentExternalId] varchar(50),
				[index] int
			)

	DECLARE @settlements_work 
			TABLE 
			(
				[id] uniqueidentifier,
				date datetime,
				[incomePaymentId] uniqueidentifier,	
				[outcomePaymentId] uniqueidentifier,
				[amount] numeric(18, 2),
				[version] uniqueidentifier,
				[isAutoGenerated] bit,
				[outcomePaymentExternalId] varchar(50),
				[index] int
			)

	DECLARE @settlementsDelete_tmp 
			TABLE 
			(
				[id] uniqueidentifier,
				[incomePaymentId] uniqueidentifier,	
				[outcomePaymentId] uniqueidentifier,
				[index] int
			)

	SET @action = ''''
	SET @requestId = ''''
	SELECT	
		@requestId = ISNULL(con.query(''requestId'').value(''.'', ''varchar(50)''), ''''),
		@action = ISNULL(con.query(''action'').value(''.'', ''varchar(50)''), '''')
	FROM  @XmlVar.nodes(''ROOT/request'') AS C ( con )



	
	SELECT @databaseId = CAST( textValue as uniqueidentifier), @localTransactionId = newid(), @deferredTransactionId = newid()  
	FROM configuration.Configuration 
	WHERE [key] = ''communication.databaseId''
	IF @databaseId IS NULL 
	BEGIN
		PRINT ''BRAK idBazy w konfiguracji''
		RETURN
	END

	SELECT @systemCurrencyId = CAST( textValue as uniqueidentifier)
	FROM configuration.Configuration 
	WHERE [key] = ''document.defaults.systemCurrencyId''
	IF @databaseId IS NULL 
	BEGIN
		PRINT ''BRAK waluty systemowej w konfiguracji''
		RETURN
	END	
	
	EXEC sp_xml_preparedocument @idoc OUTPUT, @xmlVar
	
	INSERT INTO @payments_tmp (paymentId, paymentMethodId, fullNumberDocument , contractorId , documentDate , dueDate , direction,amount , currency ,exchangeDate,  exchangeScale ,exchangeRate ,settlements, operation)
	SELECT paymentId,paymentMethodId,  fullNumberDocument , contractorId , documentDate , dueDate , direction,amount , currency ,exchangeDate,  exchangeScale ,exchangeRate, settlements, operation
	FROM OPENXML(@idoc, ''//payments/payment'')
	WITH
	(
		paymentId varchar(50) ''paymentId'',
		paymentMethodId varchar(50) ''paymentMethodId'',
		fullNumberDocument nvarchar(500) ''fullNumberDocument'',
		contractorId varchar(50) ''contractorId'',
		documentDate datetime ''documentDate'',
		dueDate datetime ''dueDate'',
		direction int ''direction'',  
		amount numeric(18,2) ''amount'',  
		currency varchar(50) ''currency'',
		exchangeDate datetime ''exchangeDate'',
		exchangeScale numeric(18,6) ''exchangeScale'',  
		exchangeRate numeric(18,6) ''exchangeRate'',
		settlements xml ''paymentSettlements'',
		operation varchar(50) ''@operation''
	)
	SELECT @rowcount = @@rowcount 
	EXEC sp_xml_removedocument @idoc
	 
	/* SPRAWDZENIE MAPOWANIA KONTRAHENTÓW */
	SET @listsContractors = ( SELECT DISTINCT p.contractorId
							  FROM @payments_tmp p
							  LEFT JOIN accounting.ExternalMapping e ON e.externalId = p.contractorId
							  WHERE e.externalId IS NULL
							  FOR XML PATH(''lists'')
							 )



	/* SPRAWDZENIE MAPOWANIA METOD PŁATNOŚCI */
	SELECT @conf = xmlValue
	FROM configuration.Configuration
	WHERE [key] = ''accounting.externalMapping.PaymentForm''					

	SET @listsPaymentMethod = (	SELECT DISTINCT paymentMethodId
								FROM @payments_tmp p
								WHERE NOT EXISTS 
									(SELECT x.value(''localSymbol[1]'',''varchar(50)'') localSymbol ,x.value(''externalSymbol[1]'',''varchar(50)'') externalSymbol
									  FROM @conf.nodes(''root/entry'') as a(x) WHERE p.paymentMethodId = x.value(''externalSymbol[1]'',''varchar(50)'')
									)
								FOR XML PATH(''lists'')
							  )


	SET @i = 1
	WHILE (@i <= @rowcount)
	BEGIN

		PRINT ''Operacja/Przebieg I:''+CAST(@i AS varchar(50))

		/*Odczyt operacji*/
		SELECT  
			@operation = t.operation, 
			@ex_settlements = t.settlements, 
			@ex_paymentId = t.paymentId ,
			@paymentId = EM.id,
			@objectType = ISNULL(EM.objectType,5),
			@direction = t.direction, 
			@paymentAmount = t.amount
		FROM @payments_tmp t
		LEFT JOIN accounting.ExternalMapping EM ON EM.externalId = paymentId
		WHERE t.id = @i

		IF (@objectType = 31) AND (@paymentId IS NOT NULL)
			SELECT @paymentId = P.id FROM finance.Payment P WHERE P.financialDocumentHeaderId = @paymentId

		/* KASOWANIE PAYMENT I POWIĄZANYCH Z NIM SETTLEMENTÓW */
		IF (@operation = ''delete'') AND (@objectType = 5)
		BEGIN
			IF @paymentId IS NOT NULL
			BEGIN
				DELETE FROM finance.PaymentSettlement WHERE @paymentId IN (incomePaymentId,outcomePaymentId)

				SELECT @version = version FROM finance.Payment WHERE id = @paymentId 
				DELETE FROM finance.Payment WHERE id = @paymentId 

				IF (@objectType = 5)
					DELETE FROM accounting.ExternalMapping WHERE id = @paymentId

				SELECT @commandXml = (	SELECT ''delete'' as ''@action'', @paymentId as ''@businessObjectId'', @databaseId as ''@databaseId'', @version as ''@previousVersion'', newid() AS ''@localTransactionId'', @deferredTransactionId as ''@deferredTransactionId''
										FOR XML PATH(''root''), TYPE )
				EXEC  [communication].[p_createPaymentPackage] @commandXml					
			END
			ELSE
				PRINT ''Próba skasowania nieistniejącego paymenta''
		END

		/* WPROWADZANIE I EDYCJA PAYMENT */
		IF (@operation = ''insertUpdate'')
		BEGIN
			PRINT ''insertUpdate operation''

			IF (@paymentId IS NULL)
			BEGIN							
				SET @paymentId = NEWID()
				SET @version = NEWID()
				PRINT ''Insert Payment''
				INSERT INTO finance.payment 
				(
					[id],
			        [date], 
					[dueDate],
					[contractorId],
					[contractorAddressId],
					[paymentMethodId], 
					[amount],
					[paymentCurrencyId],
					[systemCurrencyId],
					[exchangeDate],
					[exchangeScale],
					[exchangeRate],
					[isSettled],
					[version],
					[ordinalNumber],
					[description],								
					[documentInfo],																 
					[direction]
				)  
				SELECT TOP 1
					@paymentId, 
					t.documentDate, 
					t.dueDate,         
					ec.id,                
					ca.id,            
					pm.id, 
					@paymentAmount,             
					cur.id, 
					@systemCurrencyId,
					ISNULL(t.exchangeDate,t.documentDate),
					t.exchangeScale,
					t.exchangeRate,       
					0,  
					@version,
					1,			   
					''import z FK insert'',
					REPLACE(t.fullNumberDocument,'' '','';'') + '';''+ CONVERT(varchar(10),t.documentDate,120), 
					CASE t.direction WHEN ''2'' THEN -1 ELSE 1 END
				FROM @payments_tmp t
				LEFT JOIN accounting.ExternalMapping ec ON t.contractorId = ec.externalId
				LEFT JOIN contractor.ContractorAddress ca ON ec.id = ca.contractorId
				LEFT JOIN (
					SELECT x.value(''localSymbol[1]'',''varchar(50)'') id ,x.value(''externalSymbol[1]'',''varchar(50)'') externalSymbol
					FROM @conf.nodes(''root/entry'') as a(x) 
					) epm ON t.paymentMethodId = epm.externalSymbol
				LEFT JOIN dictionary.Currency cur ON t.currency = cur.symbol
				LEFT JOIN dictionary.PaymentMethod pm ON epm.id=pm.xmlLabels.query(''/labels[1]/label[1]'').value(''.'',''varchar(50)'')				
				WHERE t.id = @i
						
				INSERT INTO accounting.ExternalMapping
				(
					[id],
					[externalId],
					[objectType],
					[exportDate],
					[externalSystemName],
					[objectVersion]
				)
				VALUES
				(
					@paymentId,
					@ex_paymentId,
					5,
					GETDATE(),
					''FK - obce'',
					@version
				)

				SELECT @commandXml = (	SELECT @paymentId as ''@businessObjectId'', @databaseId as ''@databaseId'', @version as ''@previousVersion'', newid() AS ''@localTransactionId'', @deferredTransactionId as ''@deferredTransactionId''
										FOR XML PATH(''root''), TYPE
									 )
				EXEC communication.p_createPaymentPackage @commandXml

			END	
			ELSE
			BEGIN
				print ''update payment''

				IF (@objectType = 5)
				BEGIN
					IF (EXISTS (SELECT * FROM finance.payment))
					BEGIN
						SELECT @version = version FROM finance.Payment WHERE id = @paymentId 

						UPDATE finance.payment SET
							[date] = t.documentDate, 
							[dueDate] =  t.dueDate,
							[contractorId] = ec.id,
							[contractorAddressId] =  ca.id,
							[paymentMethodId] = ISNULL(pm.id, (select top 1 id from dictionary.PaymentMethod)), 
							[amount] = @paymentAmount,
							[paymentCurrencyId] = cur.id,
							[systemCurrencyId] = @systemCurrencyId,
							[exchangeDate] = ISNULL(t.exchangeDate,t.documentDate),
							[exchangeScale] = t.exchangeScale,
							[exchangeRate] = t.exchangeRate,
							[isSettled] = 0,
							[version] = NEWID(),
							[ordinalNumber] = 1,
							[description] = ''import z FK update'',
							[documentInfo] = REPLACE(t.fullNumberDocument,'' '','';'') + '';'' + CONVERT(varchar(10),t.documentDate, 120 ),
							[direction] = CASE t.direction WHEN ''2'' THEN -1 ELSE 1 END
						FROM finance.payment fp 
							JOIN @payments_tmp t ON 1 = 1
							LEFT JOIN accounting.ExternalMapping ec ON t.contractorId = ec.externalId AND ec.objectType = 4
							LEFT JOIN contractor.ContractorAddress ca ON ec.id = ca.contractorId
							LEFT JOIN (
										SELECT x.value(''localSymbol[1]'',''varchar(50)'') id ,x.value(''externalSymbol[1]'',''varchar(50)'') externalSymbol
										FROM @conf.nodes(''root/entry'') as a(x) 
									) epm ON t.paymentMethodId = epm.externalSymbol
							LEFT JOIN dictionary.PaymentMethod pm ON epm.id=pm.xmlLabels.query(''/labels[1]/label[1]'').value(''.'',''varchar(50)'')				
							LEFT JOIN dictionary.Currency cur ON t.currency = cur.symbol
						WHERE fp.id = @paymentId AND t.id = @i

						SELECT @commandXml = (	SELECT @paymentId as ''@businessObjectId'', @databaseId as ''@databaseId'', @version as ''@previousVersion'', newid() AS ''@localTransactionId'', @deferredTransactionId as ''@deferredTransactionId''
												FOR XML PATH(''root''), TYPE
											 )
						EXEC communication.p_createPaymentPackage @commandXml
					END
					ELSE
						DELETE FROM accounting.ExternalMapping WHERE id = @paymentId
				END									
			END	
		END
		SET @i = @i + 1
	END/* WHILE (@i <= @rowcount) */



	SET @i = 1
	WHILE (@i <= @rowcount) 
	BEGIN
		PRINT ''Operacja/Przebieg II:''+CAST(@i AS varchar(50))

		SELECT
			@operation = t.operation,   
			@paymentId = EM.id,
			@objectType = ISNULL(EM.objectType,5),
			@direction = t.direction, 
			@paymentAmount = t.amount,
			@ex_settlements = t.settlements, 
			@ex_paymentId = t.paymentId,
			@documentDate = t.documentDate
		FROM @payments_tmp t
		LEFT JOIN accounting.ExternalMapping EM ON EM.externalId = paymentId
		WHERE t.id = @i

		IF (@objectType = 31) AND (@paymentId IS NOT NULL)
			SELECT @paymentId = P.id FROM finance.Payment P WHERE P.financialDocumentHeaderId = @paymentId

		IF (@operation = ''insertUpdate'') AND (@paymentId IS NOT NULL)
		BEGIN
			/*Pobranie info o settlementach*/
			DELETE FROM @settlements_tmp 
			SET @rowcountEettlements = 0
			IF @ex_settlements IS NOT NULL 
			BEGIN
				INSERT INTO @settlements_tmp 
				SELECT
					newid(),
					CAST(x.query(''date'').value(''.'',''varchar(50)'') AS datetime),
					@paymentId,
					CASE WHEN EXISTS(SELECT * FROM accounting.ExternalMapping EM
									JOIN finance.Payment P ON P.id = EM.id 
									WHERE (externalId = x.query(''firstPaymentId'').value(''.'',''varchar(50)'')) AND 
										  (objectType IN (11,5,61) )
									) 
					THEN (SELECT TOP 1 id FROM accounting.ExternalMapping 
						  WHERE externalId = x.query(''firstPaymentId'').value(''.'',''varchar(50)'') AND objectType IN (11,5,61) )
					ELSE (SELECT TOP 1 P.id FROM accounting.ExternalMapping EM
											JOIN finance.Payment P ON P.financialDocumentHeaderId = EM.id 
											WHERE (externalId = x.query(''firstPaymentId'').value(''.'',''varchar(50)'')) AND 
												  (objectType = 31 )
						 )
					END,
					x.query(''amount'').value(''.'',''decimal(18,2)''), 
					newid(), 
					1,
					x.query(''firstPaymentId'').value(''.'',''varchar(50)''),
					row_number()over (order by x.query(''firstPaymentId'').value(''.'',''varchar(50)''))
				FROM @ex_settlements.nodes(''paymentSettlements/paymentSettlement'') as a(x)
				SET @rowcountEettlements = @@ROWCOUNT

--
--				SUMOWANIE CZESCIOWYCH ROZLICZEN TEGO SAMEGO DOKUMENTU
--
				IF (EXISTS (SELECT outcomePaymentExternalId FROM @settlements_tmp GROUP BY outcomePaymentExternalId HAVING COUNT(*) > 1))
				BEGIN

					INSERT INTO @settlements_work (outcomePaymentExternalId)
					SELECT DISTINCT outcomePaymentExternalId FROM @settlements_tmp

					UPDATE w SET
						w.id				= (SELECT TOP 1 t.id FROM @settlements_tmp t WHERE t.outcomePaymentExternalId=w.outcomePaymentExternalId),
						w.date				= (SELECT TOP 1 t.date FROM @settlements_tmp t WHERE t.outcomePaymentExternalId=w.outcomePaymentExternalId),
						w.incomePaymentId	= (SELECT TOP 1 t.incomePaymentId FROM @settlements_tmp t WHERE t.outcomePaymentExternalId=w.outcomePaymentExternalId),
						w.outcomePaymentId	= (SELECT TOP 1 t.outcomePaymentId FROM @settlements_tmp t WHERE t.outcomePaymentExternalId=w.outcomePaymentExternalId),
						w.amount			= (SELECT SUM(t.amount) FROM @settlements_tmp t WHERE t.outcomePaymentExternalId=w.outcomePaymentExternalId),
						w.isAutoGenerated	= (SELECT TOP 1 t.isAutoGenerated FROM @settlements_tmp t WHERE t.outcomePaymentExternalId=w.outcomePaymentExternalId),
						w.version			= (SELECT TOP 1 t.version FROM @settlements_tmp t WHERE t.outcomePaymentExternalId=w.outcomePaymentExternalId)
					FROM @settlements_work w

					DELETE FROM @settlements_tmp

					INSERT INTO @settlements_tmp
					SELECT 
						t.[id],
						t.[date],
						t.[incomePaymentId],	
						t.[outcomePaymentId],
						t.[amount],
						t.[version],
						t.[isAutoGenerated],
						t.[outcomePaymentExternalId],
						row_number()over (order by t.outcomePaymentExternalId)
					FROM @settlements_work t
					SET @rowcountEettlements = @@ROWCOUNT

				END
			END


			/* Obliczenie kwoty amount dla payment*/
			/* Kwoty z rozliczen  dokumentów ktorych nie ma w systemie fractus2 (brak mapowań) */
			SET @amountBO = 0.0
			SELECT @amountBO = ISNULL(SUM(ST.amount),0) FROM @settlements_tmp ST WHERE(ST.outcomePaymentId IS NULL)


			/* SPRAWDZENIE CZY PAYMENT JEST PRAWIDŁOWO ROZLICZONY */
			SET @ok = 0
			SET @k = 1
			WHILE (@k <= @rowcountEettlements)
			BEGIN
				SELECT
					@amountSettlements = ST.amount,
					@outcomePaymentId = ST.outcomePaymentId,
					@dateSettlements = ST.date
				FROM @settlements_tmp ST WHERE ST.[index] = @k	



				IF (@outcomePaymentId IS NOT NULL)
				BEGIN
					SET @amountWork = 0
					SET @settlementId = NULL
					SELECT 
						@amountWork = PS.amount,
						@settlementId = PS.id
					FROM finance.PaymentSettlement PS 
					WHERE ((PS.incomePaymentId = @paymentId) AND ( PS.outcomePaymentId = @outcomePaymentId)) OR
						  ((PS.incomePaymentId = @outcomePaymentId) AND ( PS.outcomePaymentId = @paymentId))	



					IF (@amountWork <> @amountSettlements)
					BEGIN
						SET @ok = 1
						IF (@settlementId IS NULL)
							INSERT INTO finance.PaymentSettlement
							SELECT
								NEWID(),
								@dateSettlements,
								@paymentId,	
								@outcomePaymentId,
								@amountSettlements,
								NEWID(),
								1	
						ELSE
							UPDATE finance.PaymentSettlement SET amount = @amountSettlements WHERE id = @settlementId
					END
				END	

				SET @k = @k + 1
			END 

	
			DELETE FROM @settlements_tmp WHERE outcomePaymentId IS NULL

	
			IF EXISTS (SELECT *  FROM finance.PaymentSettlement
						WHERE (@paymentId IN (incomePaymentId, outcomePaymentId)) AND 
								(NOT (id in (SELECT PS.id FROM finance.PaymentSettlement PS JOIN @settlements_tmp T ON
								((PS.outcomePaymentId = T.outcomePaymentId) AND (PS.incomePaymentId = T.incomePaymentId)) OR
								((PS.outcomePaymentId = T.incomePaymentId) AND (PS.incomePaymentId = T.outcomePaymentId)) ))) AND
								(NOT (id in (SELECT PS1.id FROM finance.PaymentSettlement PS1 JOIN accounting.ExternalPayment EP ON
								((PS1.outcomePaymentId = EP.id) OR (PS1.incomePaymentId = EP.id)) ))) )
			BEGIN
				print ''sprawdzenie kasowania''
				DELETE FROM @settlementsDelete_tmp

				INSERT INTO @settlementsDelete_tmp
					SELECT id,incomePaymentId,outcomePaymentId,row_number() over (order by id) FROM finance.PaymentSettlement
					WHERE (@paymentId IN (incomePaymentId, outcomePaymentId)) AND 
						(NOT (id in (SELECT PS.id FROM finance.PaymentSettlement PS JOIN @settlements_tmp T ON
						((PS.outcomePaymentId = T.outcomePaymentId) AND (PS.incomePaymentId = T.incomePaymentId)) OR
						((PS.outcomePaymentId = T.incomePaymentId) AND (PS.incomePaymentId = T.outcomePaymentId)) ))) AND
						(NOT (id in (SELECT PS1.id FROM finance.PaymentSettlement PS1 JOIN accounting.ExternalPayment EP ON
						((PS1.outcomePaymentId = EP.id) OR (PS1.incomePaymentId = EP.id)) )))
				SET @rowcountDelete = @@rowcount

				SET @j = 1
				WHILE (@j <= @rowcountDelete)
				BEGIN
					SELECT 
						@settlementId = SD.id,
						@incomePaymentId = SD.incomePaymentId,
						@outcomePaymentId = SD.outcomePaymentId
					FROM @settlementsDelete_tmp SD WHERE (SD.[index] = @j)

					SET @del = 1
					IF ( NOT(EXISTS(SELECT * FROM accounting.ExternalMapping EM WHERE (EM.id=@incomePaymentId))) )
						IF( NOT(EXISTS(SELECT * FROM accounting.ExternalMapping EM 
									   JOIN finance.Payment P ON EM.id = P.financialDocumentHeaderId WHERE P.id=@incomePaymentId)) )
							SET @del = 0

					IF ( NOT(EXISTS(SELECT * FROM accounting.ExternalMapping EM WHERE (EM.id=@outcomePaymentId))) )
						IF( NOT(EXISTS(SELECT * FROM accounting.ExternalMapping EM 
									   JOIN finance.Payment P ON EM.id = P.financialDocumentHeaderId WHERE P.id=@outcomePaymentId)) )
							SET @del = 0
					
					IF ( @del = 1 )
					BEGIN
						SET @ok = 1
						DELETE finance.PaymentSettlement WHERE id=@settlementId
						print ''delete settelement''
					END

					SET @j = @j + 1
				END

			END

			IF (@ok = 1)
			BEGIN
				SELECT @version = version FROM finance.Payment WHERE id = @paymentId 
				SELECT @commandXml = (	SELECT @paymentId as ''@businessObjectId'', @databaseId as ''@databaseId'', @version as ''@previousVersion'', newid() AS ''@localTransactionId'', @deferredTransactionId as ''@deferredTransactionId''
										FOR XML PATH(''root''), TYPE
								 )
				EXEC communication.p_createPaymentPackage @commandXml
			END


			IF (@amountBO <> 0)
			BEGIN
				PRINT ''jest BO''

				SET @paymentIdBO = NULL
				SELECT TOP 1 @paymentIdBO = EP.id  
				FROM accounting.ExternalPayment EP 
				JOIN finance.PaymentSettlement PS ON (EP.id = PS.incomePaymentId) OR (EP.id = PS.outcomePaymentId)
				WHERE @paymentId IN (PS.incomePaymentId,PS.outcomePaymentId)

				IF (@paymentIdBO IS NULL)
				BEGIN
					PRINT ''wprowadzenie BO''
					SET @version = NEWID()
					SET @paymentIdBO = NEWID()
					INSERT INTO finance.payment 
					(
						[id],
						[date], 
						[dueDate],
						[contractorId],
						[contractorAddressId],
						[paymentMethodId], 
						[amount],
						[paymentCurrencyId],
						[systemCurrencyId],
						[exchangeDate],
						[exchangeScale],
						[exchangeRate],
						[isSettled],
						[version],
						[ordinalNumber],
						[description],								
						[documentInfo],																 
						[direction]
					)  
					SELECT	TOP 1
						@paymentIdBO, 
						T.documentDate, 
						T.dueDate,         
						EC.id,                
						CA.id,            
						PM.id, 
						@amountBO,             
						CUR.id, 
						@systemCurrencyId,
						ISNULL(t.exchangeDate,t.documentDate),
						T.exchangeScale,
						T.exchangeRate,       
						0,  
						@version,
						1,			   
						''BO z FK'',
						''BO z FK'', 
						CASE t.direction WHEN ''2'' THEN 1 ELSE -1 END
					FROM @payments_tmp T
						LEFT JOIN accounting.ExternalMapping EC ON T.contractorId = EC.externalId
						LEFT JOIN contractor.ContractorAddress CA ON EC.id = CA.contractorId
						LEFT JOIN (
									SELECT x.value(''localSymbol[1]'',''varchar(50)'') id ,x.value(''externalSymbol[1]'',''varchar(50)'') externalSymbol
									FROM @conf.nodes(''root/entry'') as a(x) 
								) EPM ON t.paymentMethodId = EPM.externalSymbol
						LEFT JOIN dictionary.Currency CUR ON T.currency = CUR.symbol
						LEFT JOIN dictionary.PaymentMethod PM ON EPM.id=PM.xmlLabels.query(''/labels[1]/label[1]'').value(''.'',''varchar(50)'')				
					WHERE T.id = @i
						
					INSERT INTO accounting.ExternalPayment 
					VALUES
					(
						@paymentIdBO,
						@amountBO
					)

					print ''insert BO rozliczenie''

					INSERT INTO finance.PaymentSettlement
					SELECT
						NEWID(),
						@documentDate,
						@paymentId,	
						@paymentIdBO,
						@amountBO,
						NEWID(),
						1
				END
				ELSE
				BEGIN

					print ''update BO''
					SELECT @version = version FROM finance.Payment WHERE id = @paymentIdBO 

					UPDATE accounting.ExternalPayment 
					SET amount = @amountBO
					WHERE id = @paymentIdBO

					UPDATE finance.PaymentSettlement
					SET amount = @amountBO
					WHERE @paymentIdBO IN (incomePaymentId, outcomePaymentId)

					UPDATE finance.Payment
					SET amount = @amountBO
					WHERE id = @paymentIdBO 

				END

				SELECT @commandXml = (	SELECT @paymentIdBO as ''@businessObjectId'', @databaseId as ''@databaseId'', @version as ''@previousVersion'', newid() AS ''@localTransactionId'', @deferredTransactionId as ''@deferredTransactionId''
										FOR XML PATH(''root''), TYPE
									 )
				EXEC communication.p_createPaymentPackage @commandXml	

			END
			ELSE
			BEGIN
				SET @paymentIdBO = NULL
				SELECT TOP 1 @paymentIdBO = EP.id  
				FROM accounting.ExternalPayment EP 
				JOIN finance.PaymentSettlement PS ON (EP.id = PS.incomePaymentId) OR (EP.id = PS.outcomePaymentId)
				WHERE @paymentId IN (PS.incomePaymentId,PS.outcomePaymentId)

				IF (@paymentIdBO IS NOT NULL)
				BEGIN
					print ''kasowanie BO''
					DELETE FROM finance.PaymentSettlement
					WHERE (incomePaymentId = @paymentIdBO) OR (outcomePaymentId = @paymentIdBO)

					SELECT @version = version FROM finance.Payment WHERE id = @paymentIdBO 

					DELETE FROM finance.payment WHERE id = @paymentIdBO
					DELETE FROM accounting.ExternalPayment WHERE id = @paymentIdBO

					SELECT @commandXml = (	SELECT ''delete'' as ''@action'', @paymentIdBO as ''@businessObjectId'', @databaseId as ''@databaseId'', @version as ''@previousVersion'', newid() AS ''@localTransactionId'', @deferredTransactionId as ''@deferredTransactionId''
											FOR XML PATH(''root''), TYPE )
					EXEC  [communication].[p_createPaymentPackage] @commandXml					
				END
					
			END

		END 
		
		SET @i = @i + 1

	END 

	SELECT 
		@requestId AS requestId,
	    ''paymentSettlements'' AS method, 
		@action AS action
	FOR XML PATH(''request'')

	RETURN 


END



















' 
END
GO
